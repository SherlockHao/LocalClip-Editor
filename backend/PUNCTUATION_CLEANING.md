# 标点符号清理功能

## 功能概述

在翻译质量优化流程中，新增了**标点符号清理**步骤，用于删除译文中句首和句中的多余标点符号，保留句末标点。

## 执行位置

标点符号清理在**阿拉伯数字转换之后**执行，是翻译质量检查和优化的最后一步。

### 1. 语音克隆流程 (main.py)

**位置**: 第 1388-1410 行

**执行顺序**:
1. 长度检查 → 批量重新翻译超长文本
2. 汉字检测 → 替换中文字符
3. 英文检测 → 替换英文字符（仅日语/韩语）
4. **数字替换** → 将阿拉伯数字转换为目标语言发音
5. **标点清理** ← 新增步骤
6. 准备批量语音生成任务

### 2. 批量翻译流程 (main.py)

**位置**: 第 2721-2746 行

**执行顺序**:
1. 长度检查 → 批量重新翻译超长文本
2. 汉字检测 → 替换中文字符
3. 英文检测 → 替换英文字符（仅日语/韩语）
4. 英文符号问题 → 重新翻译只剩符号的句子
5. **数字替换** → 将阿拉伯数字转换为目标语言发音
6. **标点清理** ← 新增步骤
7. 翻译完成

## 核心函数

### `clean_punctuation_in_sentence(text: str) -> str`

**位置**: `text_utils.py` 第 1095-1161 行

**功能**: 清理句子中的标点符号，删除句首和句中的标点，保留句末标点

**删除的标点符号**:
- **半角**: `, . ? ! ...`
- **全角**: `，。？！…、`

**清理规则**:
1. 删除句子开头的所有标点符号
2. 删除句子中间的所有标点符号
3. 保留句子末尾的标点符号
4. 保留空格（某些语言如英语需要空格分隔单词）

## 示例

### 中文
```
输入: "，你好，世界。"
输出: "你好世界。"
```

### 英文
```
输入: "Hello, world!"
输出: "Hello world!"
```

### 日文
```
输入: "こんにちは、世界。"
输出: "こんにちは世界。"
```

### 韩文
```
输入: "안녕하세요, 세계!"
输出: "안녕하세요 세계!"
```

### 复杂情况
```
输入: "？这是，一个。测试？"
输出: "这是一个测试？"

输入: "...测试，文本..."
输出: "测试文本..."

输入: "！！！测试！！！"
输出: "测试！！！"
```

## 日志输出

处理过程中会在控制台输出以下信息：

```
[标点清理] 开始清理译文中的多余标点符号...
  [0] '，你好，世界。' -> '你好世界。'
  [5] 'Hello, world!' -> 'Hello world!'

✅ 成功清理 2 条译文中的标点
[标点清理] 保存更新后的字幕到: exports/target_xxx.srt
✅ 字幕文件已更新
```

如果没有需要清理的标点：

```
[标点清理] 开始清理译文中的多余标点符号...
ℹ️  未发现需要清理的标点
```

## 为什么需要这个功能？

### 1. 语音合成质量
TTS（文本转语音）系统在遇到句中标点时可能会产生不自然的停顿：
- 逗号 → 短停顿
- 句号 → 长停顿
- 省略号 → 拖长音

删除句中标点可以让语音更加流畅自然。

### 2. LLM 翻译问题
大语言模型在翻译时可能会：
- 在句首添加多余的标点
- 在句中保留过多的逗号和顿号
- 使用不必要的句号分隔短语

这些问题会影响语音合成的质量和听感。

### 3. 多语言一致性
不同语言对标点的使用习惯不同：
- 中文：习惯用顿号（、）
- 日文：习惯用日式逗号（、）
- 韩文：使用韩式标点

统一清理可以确保所有语言的译文都具有一致的标点风格。

## 测试

运行测试脚本验证功能：

```bash
cd c:\workspace\ai_editing\workspace\LocalClip-Editor\backend
python test_punctuation_clean.py
```

测试覆盖：
- 中文、英文、日文、韩文
- 句首、句中、句末标点处理
- 空字符串、纯标点字符串
- 多个连续标点
- 包含空格的文本

**测试结果**: 11/11 通过 ✅

## 技术实现

### 算法流程

```python
def clean_punctuation_in_sentence(text: str) -> str:
    # 1. 去除首尾空白
    text = text.strip()

    # 2. 删除句首的所有标点符号
    while text and text[0] in punctuation_to_remove:
        text = text[1:]

    # 3. 找到句末标点的起始位置
    end_punctuation_start = len(text)
    for i in range(len(text) - 1, -1, -1):
        if text[i] not in punctuation_to_remove:
            end_punctuation_start = i + 1
            break

    # 4. 分离主体和句末标点
    main_text = text[:end_punctuation_start]
    end_punctuation = text[end_punctuation_start:]

    # 5. 删除主体中的所有标点
    cleaned_main = ''.join(char for char in main_text
                           if char not in punctuation_to_remove)

    # 6. 重新组合
    return cleaned_main + end_punctuation
```

### 性能考虑

- **时间复杂度**: O(n)，其中 n 是字符串长度
- **空间复杂度**: O(n)，需要创建新字符串
- **批量处理**: 支持处理成百上千条字幕，对每条单独处理

## 与其他优化步骤的关系

| 步骤 | 顺序 | 作用 | 相互影响 |
|------|------|------|---------|
| 长度检查 | 1 | 重新翻译超长文本 | 产生新译文 |
| 汉字替换 | 2 | 替换非中文语言中的汉字 | 可能引入新标点 |
| 英文替换 | 3 | 替换日语/韩语中的英文 | 可能引入新标点 |
| 数字替换 | 4 | 阿拉伯数字→文字发音 | 可能引入新标点 |
| **标点清理** | **5** | **删除多余标点** | **清理前面所有步骤引入的标点** |

**关键**: 标点清理必须在最后执行，这样可以清理掉前面所有优化步骤中可能引入的多余标点。

## 配置和扩展

如需支持更多标点符号，修改 `text_utils.py` 中的配置：

```python
# 当前支持的标点
punctuation_to_remove = ',.?!…，。？！、'

# 扩展示例：添加分号、冒号
punctuation_to_remove = ',.?!…，。？！、;:；：'
```

## 注意事项

1. **空格不被删除**: 英语等语言需要空格分隔单词
2. **句末标点保留**: 保持句子的完整性和语调
3. **Unicode 支持**: 正确处理多语言字符（中文、日文、韩文等）
4. **幂等性**: 对同一文本多次执行结果相同

## 相关文件

- **核心实现**: `text_utils.py` (第 1095-1161 行)
- **语音克隆集成**: `main.py` (第 1388-1410 行)
- **批量翻译集成**: `main.py` (第 2721-2746 行)
- **测试脚本**: `test_punctuation_clean.py`
- **文档**: `PUNCTUATION_CLEANING.md` (本文件)
